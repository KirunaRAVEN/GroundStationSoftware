'''
    AUTHOR: Louis-Hendrik Barboutie
    CONTACT: louis.barboutie@gmail.com, loubar-3@student.ltu.se
    
    SUMMARY: The script runs a matplotlib animation to plot out the data received by the RAVEN test stand. The incoming data comes from a csv file generated by the
        serial_reader.py script, which itself receives the data from the SerialComms.cpp script. The interface is manually designed and an animation function
        handles the updating of the animated artists.

    SCRIPT STRUCTURE:

    DIRECTORY STRUCTURE:
        |
        +-- interface.py
        +-- indicatorClass.py
        +-- dataDisplayClass.py
        +-- data.csv

    CHANGELOG: 
        - 06/12/23: Improve handling of graph labelling, make displays work, add rolling average
        - 15/11/23: Added escape key press handling, header comment
        - 08/11/23: Successful implementation of animation with dummy data

    TODO:
        - add message box for software mode, substate and arduino time
'''

# ================= #
# === LIBRARIES === #
# ================= #

# external
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.animation as ani
import numpy as np
import shutil
import ctypes 
import datetime

# internal (functions)
# from update import update 
import resources.graphMath as gm
import resources.displayElements as displayElements
import resources.dataDefinitions as dataDefs
import resources.indicatorDefinitions as indicatorDefs
import resources.softwareDefinitions as softwareDefs

#import subprocess
#subprocess.Popen(["python3", "test/generateDummyData.py"])


# ============================== #
# === SELECT DATA TO DISPLAY === #
# ============================== #

graphData = [dataDefs.chamberPressure, 
             dataDefs.N2O_BottlePressure,
             dataDefs.linePressure,
             dataDefs.heatingBlanketTemperature,
             dataDefs.nozzleTemperature,
             dataDefs.loadCell,
             dataDefs.ambientTemperature,
             dataDefs.plumeTemperature]

displayData = [dataDefs.N2O_BottlePressure,
               dataDefs.heatingBlanketTemperature,
               dataDefs.loadCell]

indicatorData = [indicatorDefs.ignitionRelayIndicator, 
                 indicatorDefs.mainValveIndicator, 
                 indicatorDefs.heatingBlanketIndicator]

softwareData = [softwareDefs.mode, 
                softwareDefs.states, 
                softwareDefs.arduino]

nGraphs       = len(graphData)
nDataDisplays = len(displayData)
nSoftwareDisplays = len(softwareData)
nIndicators   = len(indicatorData)



# ======================= #
# === INTERFACE SETUP === #
# ======================= #

# ------------------------ #
# --- SETUP THE PANELS --- #
# ------------------------ #

# select backend and remove toolbar
import platform
if platform.system() == 'Windows':
    ctypes.windll.shcore.SetProcessDpiAwareness(0) # make screen scaling aware else Tkagg screws up
mpl.use("Tkagg")
mpl.style.use('fast')
plt.rcParams['toolbar'] = 'None'


# create interface figure and separate panels for the graphs, displays and indicators
interface = plt.figure(facecolor='silver') 
dataPanel, infoPanel = interface.subfigures(1, 2, width_ratios=[3,1]) 
indicatorPanel, streamPanel = infoPanel.subfigures(2, 1, height_ratios=[3,2])
displayPanel, lightsPanel = indicatorPanel.subfigures(1,2)
modePanel, logPanel = streamPanel.subfigures(1,2)

# adjust background colors of the panels
dataPanel.set_facecolor('silver')
lightsPanel.set_facecolor('slategrey') 
displayPanel.set_facecolor('slategrey')
streamPanel.set_facecolor('slategrey')
modePanel.set_facecolor('slategrey')
logPanel.set_facecolor('slategrey')



# -------------------------------------- #
# --- SETUP GRAPHS IN THE DATA PANEL --- #
# -------------------------------------- #

# create subplot layout (4 rows and 2 columns) for the graphs
graphs = dataPanel.subplots(4, 2)

# adjust spacing so that graphs don't overlap and fill out whole panel
dataPanel.subplots_adjust(left=0.05, right=0.99, bottom=0.03, top=0.97, wspace=0.15, hspace=0.4)

# plotting parameters
labelFontSize = 9
tickFontSize  = 7
nDataPoints   = 200 # the covered time span is then about nDataPoints * updateRate = 10000 ms = 10s
dataLinewidth = 0.75
warningLinewidth = 1

# add titles and axis labels to the graphs
# set limits and tick parameters
for i in range(4):
    for j in range(2):
        xLabel = '%s [%s]' % (graphData[i+j*4]['xLabel'], graphData[i+j*4]['xUnit'])
        yLabel = '%s [%s]' % (graphData[i+j*4]['yLabel'], graphData[i+j*4]['yUnit'])
        graphs[i,j].set_xlabel(xLabel, fontsize=labelFontSize)
        graphs[i,j].set_ylabel(yLabel, fontsize=labelFontSize)
        graphs[i,j].set_xlim(0, 1)
        graphs[i,j].set_ylim(graphData[i+j*4]['yLowerBound'], graphData[i+j*4]['yUpperBound'])
        graphs[i,j].set_title(graphData[i+j*4]['title'])
        graphs[i,j].tick_params(axis='y', labelsize=tickFontSize)
        graphs[i,j].tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=False) 
        graphs[i,j].axhline(graphData[i+j*4]['warningValue'], color='red', linestyle=':', linewidth=warningLinewidth)
        graphs[i,j].grid() #linestyle='--')

# add value indicators on the graphs
graphIndicators= []
for i in range(4):
    for j in range(2):
        graphIndicators.append(graphs[i][j].text(0.85, 0.05 * (graphData[i + j*4]['yUpperBound'] - graphData[i + j*4]['yLowerBound']) + graphData[i + j*4]['yLowerBound'], '',  fontweight='bold'))

# initialize line artists
dataLines = []
for i in range(4):
    for j in range(2):
        dataLines.append(graphs[i][j].plot([], [], markersize=0.5, linewidth=dataLinewidth)[0])

# initialize lists for holding the line data
x_data   = np.linspace(0, 1, nDataPoints) # common to all graphs
y_data   = [[0] * nDataPoints for _ in range(nGraphs)]
averages = [0] * nGraphs

# initialize line data
for i in range(nGraphs):
    dataLines[i].set_data(x_data, y_data[i])



# ------------------------------------------ #
# --- ADD INDICATORS TO THE LIGHTS PANEL --- #
# ------------------------------------------ #

# create a column of subplots for holding the indicators
indicators = lightsPanel.subplots(nIndicators, 1)

# adjust spacing so that indicator boxes don't overlap and fill out whole panel
lightsPanel.subplots_adjust(left=0.04, right=0.98, bottom=0.05, top=0.97, wspace=0.15, hspace=0.1)

# create lists for holding indicator objects, labels and states for easy access
indicatorObjects = []
indicatorStates  = [0] * nIndicators
for i in range(nIndicators):
    indicatorObjects.append(displayElements.indicatorLight(indicatorData[i]['title']))
    
# remove plot background and set title and square aspect ratio of the subplots
# add indicator artists to the plots
for i in range(nIndicators):
    indicators[i].set_aspect('equal', 'box')
    indicators[i].axis('off')
    for j in range(len(indicatorObjects[i].objects)):
            indicators[i].add_artist(indicatorObjects[i].objects[j])



# ------------------------------------------- #
# --- ADD DATA DISPLAYS TO THE INFO PANEL --- #
# ------------------------------------------- #

# create subplots for the info panel
displays = displayPanel.subplots(nDataDisplays, 1)

# adjust subplot geometry
# displayPanel.subplots_adjust(left=0.04, right=0.98, bottom=0.05, top=0.97, wspace=0.15, hspace=0.1)

# create display objects and value list
displayObjects = []
displayValues  = [0] * nDataDisplays
for i in range(nDataDisplays):
    displayObjects.append(displayElements.valueBox(displayData[i]['title'], displayData[i]['yUnit']))

# remove graph background and set aspect ratio of the displays
# add display artists and format display axes
for i in range(nDataDisplays):
    displays[i].set_title(displayObjects[i].title, fontsize=displayObjects[i].titleFontSize)
    displays[i].set_xlim(0, 2.5)
    displays[i].set_ylim(0, 1.0)
    displays[i].set_aspect(aspect='equal')
    displays[i].axis('off')
    for j in range(len(displayObjects[i].objects)):
        displays[i].add_artist(displayObjects[i].objects[j])
    

# ----------------------------------- #
# --- ADD SOFTWARE STATE DISPLAYS --- #
# ----------------------------------- #

softwareDisplays = modePanel.subplots(nSoftwareDisplays)

displayObjects.append(displayElements.textBox(title=softwareDefs.mode['title'], text='TBD'))
displayObjects.append(displayElements.textBox(title=softwareDefs.states['title'], text='TBD'))
displayObjects.append(displayElements.textBox(title='Arduino Time', text='TBD'))

for i in range(nSoftwareDisplays):
    softwareDisplays[i].axis('off')
    softwareDisplays[i].set_ylim(0, 1.0)
    softwareDisplays[i].set_xlim(0, 2.5)
    softwareDisplays[i].set_aspect(aspect='equal')
    softwareDisplays[i].set_title(displayObjects[nDataDisplays + i].title, fontsize=displayObjects[nDataDisplays + i].titleFontSize)

    for j in range(len(displayObjects[nDataDisplays + i].objects)):
        softwareDisplays[i].add_artist(displayObjects[nDataDisplays + i].objects[j])

# ----------------------- #
# --- ADD LOG DISPLAY --- #
# ----------------------- #

logDisplay = logPanel.subplots(1)
logDisplay.axis('off')
logDisplay.set_aspect(aspect='equal')
logDisplay.set_ylim(0, 1.6)
logDisplay.set_title('Log messages', fontsize=14)

logObject = displayElements.logBox()
for i in range(len(logObject.objects)):
    logDisplay.add_artist(logObject.objects[i])


# =========================== #
# === INTERFACE ANIMATION === #
# =========================== #

# ------------------------------ #
# --- CREATE LIST OF ARTISTS --- #
# ------------------------------ #

graphArtists = dataLines # nGraphs*2 elements

indicatorArtists = []
for i in range(nIndicators):
    indicatorArtists += indicatorObjects[i].objects # nIndicator*5 elements

displayArtists = []
for i in range(nDataDisplays + nSoftwareDisplays):
    displayArtists += displayObjects[i].objects # nDataDisplays*2 elements

modeArtists = []
logArtists = logObject.objects

# Store amount of artists for ease of access in the update function
nGraphArtists     = len(graphArtists)
nIndicatorArtists = len(indicatorArtists)
nDisplayArtists   = len(displayArtists)

artists = graphArtists + graphIndicators + indicatorArtists + displayArtists + logArtists

lastFilePosition = 0

indicatorStates[0] = 1

'''
def getLatestLine():
    # iterate to the end of the file
    line = 'hello'
    for line in dataFile: 
        pass
    return line #.decode('utf-8')
#'''

#'''
def getLatestLines(lastFilePosition):
    dataFile.seek(lastFilePosition) 
    lines = dataFile.readlines()
    lastFilePosition = dataFile.tell()
    return lines, lastFilePosition
#'''

def decodeLine(line, last_line):
    line = line.split(',')

    # convert types
    if len(line) == 23:
        for i in range(nGraphs):
            line[graphData[i]['csvIndex']] = float(line[graphData[i]['csvIndex']])
        
        for i in range(nIndicators):
            line[indicatorData[i]['csvIndex']] = int(float(line[indicatorData[i]['csvIndex']]))
        
        line[softwareData[0]['csvIndex']] = int(float(line[softwareData[0]['csvIndex']]))
        line[softwareData[1]['csvIndex']] = int(float(line[softwareData[1]['csvIndex']]))
        line[softwareData[2]['csvIndex']] = float(line[softwareData[2]['csvIndex']])
        
        maxCharPerLine = 25
        msg = line[-1].strip('\r\n') # remove trailing special characters
        if msg != ' ':
            message_updated = True
            line[-1] = [msg[i:i+maxCharPerLine] for i in range(0, len(msg), maxCharPerLine)]  
        else :
            message_updated = False      

        return line, message_updated
    else:
        return last_line, False

last_line = ''
lastFilePosition = 0
def update(frame):
    global lastFilePosition
    global indicatorStates
    global displayValues
    global last_line
    # ------------------------------- #
    # --- READ DATA FROM CSV FILE --- #
    # ------------------------------- #
    
    #line = dataFile.readline().split(',')

    # get last line from the data stream
    lines, lastFilePosition = getLatestLines(lastFilePosition) 
    for line in lines:
        line, message_updated = decodeLine(line, last_line)
        last_line = line
        if len(line) == 23:

            # ---------------------------- #
            # --- UPDATE DATA IN PLOTS --- #
            # ---------------------------- #

            # append latest data and remove earliest. Latest data is linearly interpolated according to the weight
            weight = 0.5
            for i in range(nGraphs):
                # this trick is from here:
                # https://stackoverflow.com/questions/42771110/fastest-way-to-left-cycle-a-numpy-array-like-pop-push-for-a-queue
                y_data[i][:-1] = y_data[i][1:]; y_data[i][-1] = gm.lerp(y_data[i][-1], line[graphData[i]['csvIndex']], weight)
                
            # update the data and average lines and calculate averages over the last datapoints
            for i in range(nGraphs):
                averages[i] = np.ma.average(y_data[i][-10:])
                graphArtists[i].set_xdata(x_data) # update time here
                graphArtists[i].set_ydata(y_data[i])
            
            # update the value indicator on the graphs
            for i in range(len(graphIndicators)):
                graphIndicators[i].set_text('{:.1f} {:s}'.format(y_data[i][-1], graphData[i]['yUnit']))

            # ----------------------------------- #
            # --- UPDATE THE INDICATOR LIGHTS --- #
            # ----------------------------------- #

            # get the indicator states and update the indicators
            for i in range(nIndicators):
                indicatorStates[i] = line[indicatorData[i]['csvIndex']]
                indicatorObjects[i].setState(indicatorStates[i])

            # ----------------------------- #
            # --- UPDATE DISPLAY VALUES --- #
            # ----------------------------- #
            
            for i in range(nDataDisplays):
                displayValues[i] = averages[i] # change this once new indexing going on
                displayObjects[i].setValue(displayValues[i])
                
                artistIndex = nGraphArtists + len(graphIndicators) + nIndicatorArtists + 3*i + 2 
            
                # update color
                displayObjects[i].value = averages[i]
                if averages[i] >= displayData[i]['dangerValue']:
                    artists[artistIndex].set_color('red') 
                elif averages[i] >= displayData[i]['warningValue']:
                    artists[artistIndex].set_color('darkorange')  
                else :
                    artists[artistIndex].set_color('green')

            # -------------------------------- #
            # --- UPDATE SOFTWARE DISPLAYS --- #
            # -------------------------------- #

            text = []
            text.append(softwareData[0]['modes'][line[softwareData[0]['csvIndex']]])
            text.append(softwareData[1]['states'][line[softwareData[1]['csvIndex']]])
            ms = line[softwareData[2]['csvIndex']]
            time = [float(t) for t in str(datetime.timedelta(milliseconds=ms)).split(':')]
            time = f'{time[0]:.0f}h {time[1]:.0f}m {time[2]:.0f}s'
            text.append(str(time))
            
            for i in range(nSoftwareDisplays):
                displayObjects[nDataDisplays + i].setText(text[i])
                # artistIndex = nGraphArtists + len(graphIndicators) + nIndicatorArtists + 3 * nDataDisplays + 2 + i
                # update text

            # ------------------ #
            # --- UPDATE LOG --- #
            # ------------------ #
            
            if message_updated == True:
                for msg in line[-1]:
                    logObject.updateLog(msg)
                    # not sure this is possible:
                    # update color for the tests' statuses
                    # 'passed' in green
                    # 'failed' in red
            
    return graphArtists + graphIndicators + indicatorArtists + displayArtists + logArtists



# toggle fullscreen
plt.get_current_fig_manager().full_screen_toggle()

# animation settings
isUsingBlit = True
isCachingFrameData = False
updateRate = 0 # milli seconds: seems to be faster than data rate on average

# ============================ #
# === KEY PRESSES HANDLING === #
# ============================ #

# function to add escape key press to exit figure
def escape(esc):
    if esc.key == 'escape':
        plt.close()
        
def fullscreen(f):
    if f.key == 'f':
        plt.get_current_fig_manager().full_screen_toggle()

def on_close(event):
    """
        Save a copy of the data file to archive and with timestamp
    """
    time = datetime.datetime.now().strftime('%Y-%m-%d_%Hh%M') 
    src = 'data.csv'
    dst = 'archive/'
    dst = dst + 'data_' + time + '.csv'
    shutil.copy2(src, dst)

# link the events fto the interface
interface.canvas.mpl_connect('key_press_event', escape)
interface.canvas.mpl_connect('close_event', on_close)

# ============================= #
# === ANIMATION GO BRRRRRRR === #
# ============================= #

fpath = 'dummyData.csv'
#fpath = 'data.csv'
dataFile = open(fpath, 'r')
# animate the interface
interfaceAnimation = ani.FuncAnimation(interface, update, interval=updateRate, blit=isUsingBlit, cache_frame_data=isCachingFrameData)
plt.show()

dataFile.close()
