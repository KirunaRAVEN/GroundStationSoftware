'''
    AUTHOR: Louis-Hendrik Barboutie
    CONTACT: louis.barboutie@gmail.com, loubar-3@student.ltu.se
    
    SUMMARY: The script runs a matplotlib animation to plot out the data received by the RAVEN test stand. The incoming data comes from a csv file generated by the
        serial_reader.py script, which itself receives the data from the SerialComms.cpp script. The interface is manually designed and an animation function
        handles the updating of the animated artists.

    SCRIPT STRUCTURE:

    DIRECTORY STRUCTURE:
        |
        +-- interface.py
        +-- indicatorClass.py
        +-- dataDisplayClass.py
        +-- data.csv

    CHANGELOG: 
        - 06/12/23: Improve handling of graph labelling, make displays work, add rolling average
        - 15/11/23: Added escape key press handling, header comment
        - 08/11/23: Successful implementation of animation with dummy data

    TODO:
        - add plot index, so multiple data can be displayed in the same plot. E.g. 2 blanket temps

'''

# ================= #
# === LIBRARIES === #
# ================= #

# external
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.animation as ani
import numpy as np
import csv
import shutil
import datetime

# internal (functions)
# from update import update 
import resources.graphMath as gm
import resources.displayElements as displayElements
import resources.dataDefinitions as dataDefs
import resources.indicatorDefinitions as indicatorDefs
import resources.softwareDefinitions as softwareDefs

# ============================== #
# === SELECT DATA TO DISPLAY === #
# ============================== #

# maximum 8 graph windows for readability, keep this in mind when updating graphData.   
graphData = [dataDefs.oxidizerPressure1,
             dataDefs.oxidizerPressure2,
             dataDefs.nitrogenPressure,
             dataDefs.linePressure,
             dataDefs.oxidizerBottleTemperature1,
             dataDefs.oxidizerBottleTemperature2,
             dataDefs.loadCell]

displayData = [dataDefs.oxidizerPressure1,
             dataDefs.oxidizerPressure2,
             dataDefs.nitrogenPressure,
             dataDefs.linePressure,
             dataDefs.oxidizerBottleTemperature1,
             dataDefs.oxidizerBottleTemperature2,
             dataDefs.loadCell]

indicatorData = [indicatorDefs.heatingRelayIndicator1, 
                 indicatorDefs.heatingRelayIndicator2,
                 indicatorDefs.oxidizerValve1,
                 indicatorDefs.ignitionRelayIndicator]

softwareData = [softwareDefs.mode, 
                softwareDefs.states, 
                softwareDefs.arduino]

nGraphs       = len(graphData)
nDataDisplays = len(displayData)
nTextDisplays = len(softwareData)
nIndicators   = len(indicatorData)

# ======================= #
# === Messages        === #
# ======================= #

# display message according to 'msgIndex' value in data
messageStrings = [  "",  
                    "Running testing sequence\nTesting all OFF-states...\nRelease all buttons!\n",
                    "No button presses detected\n",
                    "Please release the oxidizer valve button.\n",
                    "Please release the ignition button.\n",
                    "Please release the heating blanket button.\n",
                    ">>>  PASSED  <<<\n",
                    ">>>  FAILED  <<<\n",
                    "Ignition 24V relay OFF-state:\n",
                    "Ignition GND relay OFF-state:\n",
                    "Ignition SW relay OFF-state:\n",
                    "Heating relay OFF-state:\n",
                    "Oxidizer Valve OFF-state:\n",
                    "Testing heating relay ON-state...\nPress the Heating button!\n",
                    "Heating button press detected\n",
                    "Heating relay ON-state:\n",
                    "Release the Heating button\n",
                    "Testing Oxidizer Valve ON-state...\nPress the Oxidizer Valve button!\n",
                    "Oxidizer Valve button press detected\n",
                    "Oxidizer Valve ON-state:\n",
                    "Release the Oxidizer Valve button\n",
                    "Testing ignition relays ON-state...\nPress the Ignition button!\n",
                    "Ignition button press detected\n",
                    "Ignition Power relay ON-state:\n",
                    "Ignition Ground relay ON-state:\n",
                    "Ignition Software relay ON-state:\n",
                    "Release the Ignition button\n",
                    "Actuator testing completed...\nVerification status:\n",
                    "All tests passed!\nStarting up software...\n",
                    "Fault detected!\nFind and fix the issue!\n",
                    "Starting SW in 10 seconds\n",
                    "Warning:\nCannot begin sequence\nwith dump valve open.\n",
                    "Warning:\nCannot begin sequence\nwith N2 feeding valve open.\n",
                    "Warning:\nCannot begin sequence\nwith Oxidizer valve open.\n"]

# ======================= #
# === INTERFACE SETUP === #
# ======================= #

# ------------------------ #
# --- SETUP THE PANELS --- #
# ------------------------ #

# select backend and remove toolbar
mpl.use("qtagg")
mpl.style.use('fast')
plt.rcParams['toolbar'] = 'None'


# create interface figure and separate panels for the graphs, displays and indicators
interface = plt.figure(facecolor='silver') 
dataPanel, infoPanel = interface.subfigures(1, 2, width_ratios=[3,1]) 
indicatorPanel, streamPanel = infoPanel.subfigures(2, 1, height_ratios=[4,2])
displayPanel, lightsPanel = indicatorPanel.subfigures(1,2)
modePanel, logPanel = streamPanel.subfigures(1,2)

# adjust background colors of the panels
dataPanel.set_facecolor('silver')
lightsPanel.set_facecolor('silver') 
displayPanel.set_facecolor('silver')
streamPanel.set_facecolor('silver')
modePanel.set_facecolor('silver')
logPanel.set_facecolor('silver')



# -------------------------------------- #
# --- SETUP GRAPHS IN THE DATA PANEL --- #
# -------------------------------------- #

# create subplot layout (4 rows and 2 columns) for the graphs
graphs = dataPanel.subplots(4, 2)

# adjust spacing so that graphs don't overlap and fill out whole panel
dataPanel.subplots_adjust(left=0.05, right=0.99, bottom=0.03, top=0.97, wspace=0.15, hspace=0.4)

# plotting parameters
labelFontSize = 9
tickFontSize  = 7
nDataPoints   = 50 # the covered time span is then about nDataPoints * updateRate = 10000 ms = 10s
dataLinewidth = 1.5
warningLinewidth = 2

# add titles and axis labels to the graphs
# set limits and tick parameters
for i in range(4):
    for j in range(2):
        if (i+j*4 < nGraphs):
            xLabel = '%s [%s]' % (graphData[i+j*4]['xLabel'], graphData[i+j*4]['xUnit'])
            yLabel = '%s [%s]' % (graphData[i+j*4]['yLabel'], graphData[i+j*4]['yUnit'])
            graphs[i,j].set_xlabel(xLabel, fontsize=labelFontSize)
            graphs[i,j].set_ylabel(yLabel, fontsize=labelFontSize)
            graphs[i,j].set_xlim(0, 1)
            graphs[i,j].set_ylim(graphData[i+j*4]['yLowerBound'], graphData[i+j*4]['yUpperBound'])
            graphs[i,j].set_title(graphData[i+j*4]['title'])
            graphs[i,j].tick_params(axis='y', labelsize=tickFontSize)
            graphs[i,j].tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=False) 
            graphs[i,j].axhline(graphData[i+j*4]['warningValue'], color='red', linestyle=':', linewidth=warningLinewidth)
            graphs[i,j].grid() #linestyle='--')
        else:
            graphs[i,j].remove()

# add value indicators on the graphs
graphIndicators= []
for i in range(4):
    for j in range(2):
        if (i+j*4 < nGraphs):   
            graphIndicators.append(graphs[i][j].text(0.85, 0.05 * (graphData[i + j*4]['yUpperBound'] - graphData[i + j*4]['yLowerBound']) + graphData[i + j*4]['yLowerBound'], '',  fontweight='bold'))

# initialize line artists
dataLines = []
for i in range(4):
    for j in range(2):
        if (i+j*4 < nGraphs):
            dataLines.append(graphs[i][j].plot([], [], '-', markersize=0.5, linewidth=dataLinewidth)[0])
            
# initialize lists for holding the line data
x_data   = np.linspace(0, 1, nDataPoints) # common to all graphs
y_data   = [[0] * nDataPoints for _ in range(nGraphs)]
averages = [0] * nGraphs

# initialize line data
for i in range(nGraphs):
    dataLines[i].set_data(x_data, y_data[i])



# ------------------------------------------ #
# --- ADD INDICATORS TO THE LIGHTS PANEL --- #
# ------------------------------------------ #

# create a column of subplots for holding the indicators
indicators = lightsPanel.subplots(nIndicators, 1)

# adjust spacing so that indicator boxes don't overlap and fill out whole panel
lightsPanel.subplots_adjust(left=0.04, right=0.98, bottom=0.05, top=0.97, wspace=0.15, hspace=0.1)

# create lists for holding indicator objects, labels and states for easy access
indicatorObjects = []
indicatorStates  = [0] * nIndicators
for i in range(nIndicators):
    indicatorObjects.append(displayElements.indicatorLight(indicatorData[i]['title']))
    
# remove plot background and set title and square aspect ratio of the subplots
# add indicator artists to the plots
for i in range(nIndicators):
    indicators[i].set_aspect('equal', 'box')
    indicators[i].axis('off')
    for j in range(len(indicatorObjects[i].objects)):
            indicators[i].add_artist(indicatorObjects[i].objects[j])



# ------------------------------------------- #
# --- ADD DATA DISPLAYS TO THE INFO PANEL --- #
# ------------------------------------------- #

# create subplots for the info panel
displays = displayPanel.subplots(nDataDisplays, 1)

# adjust subplot geometry
# displayPanel.subplots_adjust(left=0.04, right=0.98, bottom=0.05, top=0.97, wspace=0.15, hspace=0.1)

# create display objects and value list
displayObjects = []
displayValues  = [0] * nDataDisplays
for i in range(nDataDisplays):
    displayObjects.append(displayElements.valueBox(displayData[i]['title'], displayData[i]['yUnit']))

# remove graph background and set aspect ratio of the displays
# add display artists and format display axes
for i in range(nDataDisplays):
    displays[i].set_title(displayObjects[i].title, fontsize=displayObjects[i].titleFontSize)
    displays[i].set_xlim(0, 2.5)
    displays[i].set_ylim(0, 1.0)
    displays[i].set_aspect(aspect='equal')
    displays[i].axis('off')
    for j in range(len(displayObjects[i].objects)):
        displays[i].add_artist(displayObjects[i].objects[j])
    

# ----------------------------------- #
# --- ADD SOFTWARE STATE DISPLAYS --- #
# ----------------------------------- #

# nModeDisplays = len(modeData)
# modeDisplays = modePanel.subplots(nModeDisplays)

# for i in range(nModeDisplays):
#     displayObjects.append(displayElements.textBox(title=modeData[i], text='TBD'))
#     modeDisplays[i].axis('off')
#     modeDisplays[i].set_ylim(0, 1.0)
#     modeDisplays[i].set_xlim(0, 2.5)
#     modeDisplays[i].set_aspect(aspect='equal')
#     modeDisplays[i].set_title(displayObjects[nDataDisplays + i].title, fontsize=displayObjects[nDataDisplays + i].titleFontSize)
#     for j in range(len(displayObjects[nDataDisplays + i].objects)):
#         modeDisplays[i].add_artist(displayObjects[nDataDisplays + i].objects[j])

nSoftwareDisplays = 3
softwareDisplays = modePanel.subplots(nSoftwareDisplays)

displayObjects.append(displayElements.textBox(title=softwareDefs.mode['title'], text='TBD'))
displayObjects.append(displayElements.textBox(title=softwareDefs.states['title'], text='TBD'))
displayObjects.append(displayElements.textBox(title='Arduino Time', text='TBD'))

for i in range(nSoftwareDisplays):
    softwareDisplays[i].axis('off')
    softwareDisplays[i].set_ylim(0, 1.0)
    softwareDisplays[i].set_xlim(0, 2.5)
    softwareDisplays[i].set_aspect(aspect='equal')
    softwareDisplays[i].set_title(displayObjects[nDataDisplays + i].title, fontsize=displayObjects[nDataDisplays + i].titleFontSize)

    for j in range(len(displayObjects[nDataDisplays + i].objects)):
        softwareDisplays[i].add_artist(displayObjects[nDataDisplays + i].objects[j])

# ----------------------- #
# --- ADD LOG DISPLAY --- #
# ----------------------- #

logDisplay = logPanel.subplots(1)
logDisplay.axis('off')
logDisplay.set_aspect(aspect='equal')
logDisplay.set_ylim(0, 1.6)
logDisplay.set_title('Log messages', fontsize=14)

logObject = displayElements.logBox()
for i in range(len(logObject.objects)):
    logDisplay.add_artist(logObject.objects[i])


# =========================== #
# === INTERFACE ANIMATION === #
# =========================== #

# ------------------------------ #
# --- CREATE LIST OF ARTISTS --- #
# ------------------------------ #

graphArtists = dataLines # nGraphs*2 elements

indicatorArtists = []
for i in range(nIndicators):
    indicatorArtists += indicatorObjects[i].objects # nIndicator*5 elements

displayArtists = []
for i in range(nDataDisplays + nTextDisplays):
    displayArtists += displayObjects[i].objects # nDataDisplays*2 elements

modeArtists = []
logArtists = logObject.objects

# Store amount of artists for ease of access in the update function
nGraphArtists     = len(graphArtists)
nIndicatorArtists = len(indicatorArtists)
nDisplayArtists   = len(displayArtists)

artists = graphArtists + graphIndicators + indicatorArtists + displayArtists + logArtists

last_pos = 0

indicatorStates[0] = 1

# Store the last valid line globally
last_valid_line = None

# ------------------------------------- #
# --- Validate the data in CSV file --- #
# ------------------------------------- #
def validate_CSV_data(line):
    global last_valid_line  # Reference the global variable

    #line = line.strip().split(',')

    # Checking the first line to make sure it is not the header
    print(line[0])
    if line[0] == "ArduinoMegaTime": 
        return last_valid_line
    # Checks if line contains 25 variables
    #if len(line) != 25:
    #    return last_valid_line  # Returns last line if this is the case

    # If the line contains 25 variables it changes last valid line to the current one and then returns the current one
    last_valid_line = line
    return line

def update(frame):
    global indicatorStates
    global displayValues

    print("new update call")
    
    # ------------------------------- #
    # --- READ DATA FROM CSV FILE --- #
    # ------------------------------- #
    
    #line = dataFile.readline().split(',')
    global csv_file
    global last_pos
    csv_reader = csv.reader(csv_file)
    csv_file.seek(last_pos)

    cuntr = 0
    for line in csv_reader:
        cuntr += 1
        if cuntr == 2:
            for line2 in csv_reader:
                pass
            break

        line = validate_CSV_data(line)
        if line == None:
            continue
        
        # ---------------------------- #
        # --- UPDATE DATA IN PLOTS --- #
        # ---------------------------- #

        weight = 0
        for i in range(nGraphs):
            # this trick is from here:
            # https://stackoverflow.com/questions/42771110/fastest-way-to-left-cycle-a-numpy-array-like-pop-push-for-a-queue
            y_data[i][:-1] = y_data[i][1:]; y_data[i][-1] = gm.lerp(y_data[i][-1], float(line[graphData[i]['csvIndex']]), weight)

        # update the data and average lines and calculate averages
        for i in range(nGraphs):
            averages[i] = gm.rollingAverage(y_data[i])
            artists[i].set_ydata(y_data[i])

        print("updated data in plots")

        # ----------------------------------------- #
        # --- DUMMY UPDATE THE INDICATOR LIGHTS --- #
        # ----------------------------------------- #

        # get the indicator states and update the indicators
        for i in range(nIndicators):
            indicatorStates[i] = int(float(line[indicatorData[i]['csvIndex']]))
            indicatorObjects[i].setState(indicatorStates[i])

        print("updated indicator states")

        # ----------------------------- #
        # --- UPDATE DISPLAY VALUES --- #
        # ----------------------------- #

        for i in range(nDataDisplays):
            displayValues[i] = averages[i] # change this once new indexing going on
            displayObjects[i].setValue(displayValues[i])

            artistIndex = nGraphArtists + len(graphIndicators) + nIndicatorArtists + 3*i + 2 

            # update color
            displayObjects[i].value = averages[i]
            if averages[i] >= displayData[i]['dangerValue']:
                artists[artistIndex].set_color('red') 
            elif averages[i] >= displayData[i]['warningValue']:
                artists[artistIndex].set_color('darkorange')  
            else :
                artists[artistIndex].set_color('green')

        print("updated display values")

        # -------------------------------- #
        # --- UPDATE SOFTWARE DISPLAYS --- #
        # -------------------------------- #

        text = []
        text.append(softwareData[0]['modes'][int(float(line[softwareData[0]['csvIndex']]))])
        text.append(softwareData[1]['states'][int(float(line[softwareData[1]['csvIndex']]))])
        us = float(line[softwareData[2]['csvIndex']])
        time = [float(t) for t in str(datetime.timedelta(microseconds=us)).split(':')]
        time = f'{time[0]:.0f}h {time[1]:.0f}m {time[2]:.2f}s'
        text.append(str(time))

        for i in range(nTextDisplays):
            displayObjects[nDataDisplays + i].setText(text[i])
            # artistIndex = nGraphArtists + len(graphIndicators) + nIndicatorArtists + 3 * nDataDisplays + 2 + i
            # update text

        print("updated software displays")

        # ------------------ #
        # --- UPDATE LOG --- #
        # ------------------ #

        msgIndex = line[-1].strip('\n')
        msg = messageStrings[int(msgIndex)]

        if msg != ' ':
            logObject.updateLog(msg)

        print("updated log")

    last_pos = csv_file.tell()
    print("returning artists...")
    return artists



# toggle fullscreen
# done elsewhere
#plt.get_current_fig_manager().full_screen_toggle()

# animation settings
isUsingBlit = True
isCachingFrameData = False
updateRate = 0 # plot as fast as possible



# function to add escape key press to exit figure
def escape(esc):
    if esc.key == 'escape':
        plt.close()
        
def fullscreen(f):
    if f.key == 'f':
        plt.get_current_fig_manager().full_screen_toggle()

def on_close(event):
    """
        Save a copy of the data file to archive and with timestamp
    """
    time = datetime.datetime.now().strftime('%Y-%m-%d_%Hh%M') 
    src = 'data.csv'
    dst = 'archive/'
    dst = dst + 'data_' + time + '.csv'
    shutil.copy2(src, dst)

# link the events fto the interface
interface.canvas.mpl_connect('key_press_event', escape)
interface.canvas.mpl_connect('close_event', on_close)

'''
fpath = 'data.csv'
dataFile = open(fpath, 'r')
# animate the interface
interfaceAnimation = ani.FuncAnimation(interface, update, interval=updateRate, blit=isUsingBlit, cache_frame_data=isCachingFrameData)
plt.show()
'''

csv_file = None
# otherwise, read the new data from the file
with open('data.csv', 'r') as csv_file:

    # Make the window fullscreen
    manager = plt.get_current_fig_manager()
    manager.full_screen_toggle()

    interfaceAnimation = ani.FuncAnimation(interface, update, interval=updateRate, blit=isUsingBlit, cache_frame_data=isCachingFrameData)

    plt.show()
